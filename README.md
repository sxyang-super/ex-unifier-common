
| Problem | Definition | Throw exception | Check exception | Unified response |
|---------|------------|-----------------|-----------------|------------------|
| Define a custom exception | `class CustomException extends RuntimeException { message code data }` | `throw new CustomException()` | `if (e instanceof CustomException) { do something }` | Handle CustomException http status code: 200 response body { code: e.code message: e.message data :e.data } |
| Need one handler for each type of Exception | `class CustomException2 extends RuntimeException { msg code }` | | | Handle CustomException2 http status code: 200 response body { code: e.code message: e.msg data :e.data } |
| Define a base exception class | `class BaseException extends RuntimeException { message code data } class CustomException extends BaseException { }` | | | Handle BaseException http status code: 200 response body { code: e.code message: e.message data :e.data } |
| For error message like `Fail to handle submission as order status is (CANCELLED/ESCALATED) already` | `class FailHandleSubmissionException extends BaseException { }` | `throw new FailHandleSubmissionException (Fail to handle submission as order status is CANCELLED already)` `throw new FailHandleSubmissionException (Fail to handle submission as order status is ESCALATED already)` | |
| Add args support to message | `class FailHandleSubmissionException extends BaseException { message = 'Fail to handle submission as order status is ${orderStatus} already' orderStatus }` | `throw new FailHandleSubmissionException ('CANCELLED')` `throw new FailHandleSubmissionException ('ESCALATED')` | |
| Level up message args to base exception | `class BaseException extends RuntimeException { message code data args } class FailHandleSubmissionException extends BaseException { message = 'Fail to handle submission as order status is ${arg[0]} already' }` | `throw new FailHandleSubmissionException ('CANCELLED')` `throw new FailHandleSubmissionException ('ESCALATED')` | |
| Different devs use same exception code causing misunderstanding to client | `class FailHandleSubmissionException extends BaseException { code=1 } class FailHandleCancellationException extends BaseException { code=1 }` | | |
| Define a global exception code enum | `enum ExceptionCode { final code; final message; -- settled with code FAIL_HANDLE_SUBMISSION(1, 'Fail to handle submission as order status is ${arg[0]} already') FAIL_HANDLE_CANCELLATION(1, 'Fail to handle cancellation as order status is ${arg[0]} already') } class BaseException extends RuntimeException { message: ExceptionCode code data args }` | `throw new BaseException (ExceptionCode.FAIL_HANDLE_SUBMISSION, 'CANCELLED')` `throw new BaseException (ExceptionCode.FAIL_HANDLE_CANCELLATION, 'ESCALATED')` | Handle BaseException http status code: 200 response body { code: e.code.getCode() message: e.message data :e.data } |
| In multiple module project, it's still possible of duplicated exception code | `module1: com.example.module1 enum ExceptionCode { final code; final message; -- settled with code EX1(1, 'error message') EX2(2, 'error message') } module2: com.example.module2 enum ExceptionCode { final code; final message; -- settled with code EX1(1, 'error message') EX2(2, 'error message') } module3, import module1 and module2` | | |
| Add module prefix | `module1: com.example.module1 enum ExceptionCode { final code; final message; -- settled with code EX1(M1_1, 'error message') EX2(M1_2, 'error message') } module2: com.example.module2 enum ExceptionCode { final code; final message; -- settled with code EX1(M2_1, 'error message') EX2(M2_2, 'error message') } module3, import module1 and module2` | | |
| Using annotation to provide exception code prefix and at compile period, prepend prefix automatically | `module1: com.example.module1 @CodePrefix('M1_') enum ExceptionCode { final code; final message; -- settled with code EX1(1, 'error message') EX2(2, 'error message') } module2: com.example.module2 @CodePrefix('M2_') enum ExceptionCode { final code; final message; -- settled with code EX1(1, 'error message') EX2(2, 'error message') } After compile interceptor module1: com.example.module1 enum ExceptionCode { final code; final message; -- settled with code EX1(M1_1, 'error message') EX2(M1_2, 'error message') } module2: com.example.module2 enum ExceptionCode { final code; final message; -- settled with code EX1(M2_1, 'error message') EX2(M2_2, 'error message') } module3, import module1 and module2` | | |
| Different maintainer to different module don't know the prefix of each other, may cause duplication again | `module1: com.example.module1 @CodePrefix('M1_') enum ExceptionCode { final code; final message; -- settled with code EX1(1, 'error message') EX2(2, 'error message') } module2: com.example.module2 @CodePrefix('M1_') enum ExceptionCode { final code; final message; -- settled with code EX1(1, 'error message') EX2(2, 'error message') } module3, import module1 and module2` | | |
| Introduce a centralized exception code prefix source | `module1: com.example.module1 enum ExceptionCode { final code; final message; -- settled with code EX1(M1_1, 'error message') EX2(M1_2, 'error message') } module2: com.example.module2 enum ExceptionCode { final code; final message; -- settled with code EX1(M2_1, 'error message') EX2(M2_2, 'error message') } module3, import module1 and module2 -- centralized exception code prefix source { "com.example.module1": "M1_", "com.example.module2": "M2_", }` | | |
| For some exception, exception message is not for client. Example: Client: sending an encrypted string to server Server: need to decrypt that string and check. In server, it's trying to get the decrypt key, but it's absent. And in message, we want to set message like "secret is missing for xxx", xxx is good for debugging, but not good to expose to client. But we need to return specific exception code to client and it's good when client ask support from server team. | `enum ExceptionCode { final code; final message; -- settled with code DESCYPT_KEY_ABSENT(1, 'descypt key is abset for ${args[0]}') }` | | Handle BaseException http status code: 200 response body { code: e.code.getCode() message: getMaskedMessage(e) data :e.data } getMaskedMessage(e) { if (e.code = DESCYPT_KEY_ABSENT) { return 'unknown server error, please contact support team' } else { return e.message } } |
| Introduce exception source in which tells the source of this exception. And we add it into exception code. | `enum ExceptionCode { final code; final message; -- settled with code DESCYPT_KEY_ABSENT(SYSTEM_1, 'descypt key is abset for ${args[0]}'), FAIL_HANDLE_CANCELLATION(USER_2, 'Fail to handle cancellation as order status is ${arg[0]} already') }` | | Handle BaseException http status code: 200 response body { code: e.code.getCode() message: getMaskedMessage(e) data :e.data } getMaskedMessage(e) { if (e.code.indexOf('SYSTEM_') > -1) { return 'unknown server error, please contact support team' } else { return e.message } } |
| Use annotation to tell the source. Inject in compile period. And split ExceptionCode into two, one for USER, one for SYSTEM | `@ExceptionSource('USER_') enum UserExceptionCode { final code; final message; -- settled with code FAIL_HANDLE_CANCELLATION(1, 'Fail to handle cancellation as order status is ${arg[0]} already') } @ExceptionSource('SYSTEM_') enum SystemExceptionCode { final code; final message; -- settled with code DESCYPT_KEY_ABSENT(1, 'descypt key is abset for ${args[0]}'), }` | | |
| When throw exception, usually there is a if check before it. | | `If (secret = null) { throw .... } If (password = '') { throw .... }` | |
| Introduce assert pattern | | `DESCYPT_KEY_ABSENT.assertNotNull(secret, 'xxx') ------- DESCYPT_KEY_ABSENT enum if (secret = null) { throw new BaseException(this, args) }` | |
| All modules are using BaseException is not good for identifying. Each module should have its own base exception. | `module1: com.example.module1 public class Module1BaseException {}` | `DESCYPT_KEY_ABSENT.assertNotNull(secret, 'xxx') ------- DESCYPT_KEY_ABSENT enum if (secret = null) { throw new Module1BaseException(this, args) }` | |
